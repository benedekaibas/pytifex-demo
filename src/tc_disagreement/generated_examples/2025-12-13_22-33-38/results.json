{
    "timestamp": "2025-12-13_22-33-38",
    "checkers_used": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
    ],
    "results": [
        {
            "filename": "paramspec-classmethod-staticmethod.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:36: note: Revealed type is \"def (name: builtins.str, id: builtins.int) -> paramspec-classmethod-staticmethod.MyUtility\"\ngenerated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:39: note: Revealed type is \"def (prefix: builtins.str =) -> builtins.str\"\nSuccess: no issues found in 1 source file",
                "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:36:5\n   |\n36 |     reveal_type(MyUtility.create_instance)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: BoundMethod[type[MyUtility], (cls: type[MyUtility], name: str, id: int) -> MyUtility] [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:36:16\n   |\n36 |     reveal_type(MyUtility.create_instance)\n   |                ---------------------------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:39:5\n   |\n39 |     reveal_type(MyUtility.generate_uuid)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: (prefix: str = ...) -> str [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:39:16\n   |\n39 |     reveal_type(MyUtility.generate_uuid)\n   |                -------------------------\n   |\n\n[STDERR]\n INFO 2 errors",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:36: note: Revealed type is \"def (name: builtins.str, id: builtins.int) -> generated_examples.2025-12-13_22-33-38.source_files.paramspec-classmethod-staticmethod.MyUtility\"\ngenerated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:39: note: Revealed type is \"def (prefix: builtins.str =) -> builtins.str\"\nSuccess: no issues found in 1 source file",
                "ty": "error[unresolved-attribute]: Object of type `(**P@log_args_decorator) -> R@log_args_decorator` has no attribute `__name__`\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:17:26\n   |\n15 | def log_args_decorator(func: Callable[P, R]) -> Callable[P, R]:\n16 |     def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n17 |         print(f\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\")\n   |                          ^^^^^^^^^^^^^\n18 |         return func(*args, **kwargs)\n19 |     return wrapper\n   |\ninfo: rule `unresolved-attribute` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `id`\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:35:16\n   |\n34 | if __name__ == \"__main__\":\n35 |     instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n36 |     reveal_type(MyUtility.create_instance)\n   |\ninfo: Union variant `(cls, name: str, id: int) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str, id: int) -> Unknown) | ((cls, name: Divergent, id: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `id`\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:35:16\n   |\n34 | if __name__ == \"__main__\":\n35 |     instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n36 |     reveal_type(MyUtility.create_instance)\n   |\ninfo: Union variant `(cls, name: Divergent, id: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str, id: int) -> Unknown) | ((cls, name: Divergent, id: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[invalid-argument-type]: Argument is incorrect\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:35:42\n   |\n34 | if __name__ == \"__main__\":\n35 |     instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n   |                                          ^^^^^^^^^^^ Expected `Self@create_instance`, found `Literal[\"test_item\"]`\n36 |     reveal_type(MyUtility.create_instance)\n   |\ninfo: Union variant `(cls, name: Divergent, id: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str, id: int) -> Unknown) | ((cls, name: Divergent, id: Divergent) -> Unknown)`\ninfo: rule `invalid-argument-type` is enabled by default\n\nerror[invalid-argument-type]: Argument is incorrect\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:35:55\n   |\n34 | if __name__ == \"__main__\":\n35 |     instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n   |                                                       ^^^ Expected `str`, found `Literal[123]`\n36 |     reveal_type(MyUtility.create_instance)\n   |\ninfo: Union variant `(cls, name: str, id: int) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str, id: int) -> Unknown) | ((cls, name: Divergent, id: Divergent) -> Unknown)`\ninfo: rule `invalid-argument-type` is enabled by default\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:36:5\n   |\n34 | if __name__ == \"__main__\":\n35 |     instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n36 |     reveal_type(MyUtility.create_instance)\n   |     ^^^^^^^^^^^\n37 |\n38 |     uuid_val = MyUtility.generate_uuid(\"prefix\")\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:36:17\n   |\n34 | if __name__ == \"__main__\":\n35 |     instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n36 |     reveal_type(MyUtility.create_instance)\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ `((cls, name: str, id: int) -> Unknown) | ((cls, name: Divergent, id: Divergent) -> Unknown)`\n37 |\n38 |     uuid_val = MyUtility.generate_uuid(\"prefix\")\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:39:5\n   |\n38 |     uuid_val = MyUtility.generate_uuid(\"prefix\")\n39 |     reveal_type(MyUtility.generate_uuid)\n   |     ^^^^^^^^^^^\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/paramspec-classmethod-staticmethod.py:39:17\n   |\n38 |     uuid_val = MyUtility.generate_uuid(\"prefix\")\n39 |     reveal_type(MyUtility.generate_uuid)\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^ `((prefix: str = Literal[\"\"]) -> Unknown) | ((prefix: Divergent = Divergent) -> Unknown)`\n   |\n\nFound 9 diagnostics"
            }
        },
        {
            "filename": "final-override-property.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/final-override-property.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:17: error: Cannot override final attribute \"API_KEY\" (previously declared in base class \"BaseSettings\")  [misc]\ngenerated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:27: note: Revealed type is \"builtins.str\"\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR `API_KEY` is declared as final in parent class `BaseSettings` [bad-override]\n  --> generated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:18:9\n   |\n18 |     def API_KEY(self) -> str:\n   |         ^^^^^^^\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:27:5\n   |\n27 |     reveal_type(prod_config.API_KEY)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: str [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:27:16\n   |\n27 |     reveal_type(prod_config.API_KEY)\n   |                ---------------------\n   |\n\n[STDERR]\n INFO 2 errors",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:17: error: Cannot override final attribute \"API_KEY\" (previously declared in base class \"BaseSettings\")  [misc]\ngenerated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:27: note: Revealed type is \"builtins.str\"\nFound 1 errors in 1 file (checked 1 source file)",
                "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:27:5\n   |\n25 |     prod_config = ProdSettings()\n26 |     print(f\"Prod API Key: {prod_config.API_KEY}\")\n27 |     reveal_type(prod_config.API_KEY)\n   |     ^^^^^^^^^^^\n28 |     print(f\"Base Timeout: {prod_config.TIMEOUT}\")\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/final-override-property.py:27:17\n   |\n25 |     prod_config = ProdSettings()\n26 |     print(f\"Prod API Key: {prod_config.API_KEY}\")\n27 |     reveal_type(prod_config.API_KEY)\n   |                 ^^^^^^^^^^^^^^^^^^^ `str`\n28 |     print(f\"Base Timeout: {prod_config.TIMEOUT}\")\n   |\n\nFound 2 diagnostics"
            }
        },
        {
            "filename": "newtype-list-covariance.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:28: error: Argument 1 to \"get_customer_orders\" has incompatible type \"list[int]\"; expected \"list[CustomerId]\"  [arg-type]\ngenerated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:29: note: Revealed type is \"builtins.list[builtins.str]\"\ngenerated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:32: error: Argument 1 to \"process_product_data\" has incompatible type \"list[int]\"; expected \"list[ProductId]\"  [arg-type]\nFound 2 errors in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Argument `list[int]` is not assignable to parameter `customer_ids` with type `list[CustomerId]` in function `get_customer_orders` [bad-argument-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:28:38\n   |\n28 |     orders_raw = get_customer_orders(raw_customer_ids) # Checkers disagree here\n   |                                      ^^^^^^^^^^^^^^^^\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:29:5\n   |\n29 |     reveal_type(orders_raw)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: list[str] [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:29:16\n   |\n29 |     reveal_type(orders_raw)\n   |                ------------\n   |\nERROR Argument `list[int]` is not assignable to parameter `product_ids` with type `list[ProductId]` in function `process_product_data` [bad-argument-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:32:26\n   |\n32 |     process_product_data(raw_product_ids) # Similar divergence point\n   |                          ^^^^^^^^^^^^^^^\n   |\n\n[STDERR]\n INFO 3 errors",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:28: error: Argument 1 to \"get_customer_orders\" has incompatible type \"list[int]\"; expected \"list[CustomerId]\"  [arg-type]\ngenerated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:29: note: Revealed type is \"builtins.list[builtins.str]\"\ngenerated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:32: error: Argument 1 to \"process_product_data\" has incompatible type \"list[int]\"; expected \"list[ProductId]\"  [arg-type]\nFound 2 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-argument-type]: Argument to function `get_customer_orders` is incorrect\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:28:38\n   |\n26 |     raw_customer_ids: list[int] = [201, 202, 203]\n27 |     # Mypy typically flags this as an error. Pyright/Pyre/Zuban often allow it.\n28 |     orders_raw = get_customer_orders(raw_customer_ids) # Checkers disagree here\n   |                                      ^^^^^^^^^^^^^^^^ Expected `list[CustomerId]`, found `list[int]`\n29 |     reveal_type(orders_raw)\n   |\ninfo: Function defined here\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:14:5\n   |\n12 | ProductId = NewType('ProductId', int)\n13 |\n14 | def get_customer_orders(customer_ids: list[CustomerId]) -> list[str]:\n   |     ^^^^^^^^^^^^^^^^^^^ ------------------------------ Parameter declared here\n15 |     \"\"\"Simulates fetching orders for a list of customer IDs.\"\"\"\n16 |     return [f\"Order for customer {cid}\" for cid in customer_ids]\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:29:5\n   |\n27 |     # Mypy typically flags this as an error. Pyright/Pyre/Zuban often allow it.\n28 |     orders_raw = get_customer_orders(raw_customer_ids) # Checkers disagree here\n29 |     reveal_type(orders_raw)\n   |     ^^^^^^^^^^^\n30 |\n31 |     raw_product_ids: list[int] = [10, 20]\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:29:17\n   |\n27 |     # Mypy typically flags this as an error. Pyright/Pyre/Zuban often allow it.\n28 |     orders_raw = get_customer_orders(raw_customer_ids) # Checkers disagree here\n29 |     reveal_type(orders_raw)\n   |                 ^^^^^^^^^^ `list[str]`\n30 |\n31 |     raw_product_ids: list[int] = [10, 20]\n   |\n\nerror[invalid-argument-type]: Argument to function `process_product_data` is incorrect\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:32:26\n   |\n31 |     raw_product_ids: list[int] = [10, 20]\n32 |     process_product_data(raw_product_ids) # Similar divergence point\n   |                          ^^^^^^^^^^^^^^^ Expected `list[ProductId]`, found `list[int]`\n   |\ninfo: Function defined here\n  --> generated_examples/2025-12-13_22-33-38/source_files/newtype-list-covariance.py:18:5\n   |\n16 |     return [f\"Order for customer {cid}\" for cid in customer_ids]\n17 |\n18 | def process_product_data(product_ids: list[ProductId]) -> None:\n   |     ^^^^^^^^^^^^^^^^^^^^ ---------------------------- Parameter declared here\n19 |     print(f\"Processing products: {product_ids}\")\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 4 diagnostics"
            }
        },
        {
            "filename": "protocol-call-positional-keyword.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:28: note: Revealed type is \"protocol-call-positional-keyword.DataSerializer\"\ngenerated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:31: note: Revealed type is \"builtins.bytes\"\ngenerated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:34: note: Revealed type is \"builtins.bytes\"\nSuccess: no issues found in 1 source file",
                "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:28:5\n   |\n28 |     reveal_type(serializer)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: DataSerializer [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:28:16\n   |\n28 |     reveal_type(serializer)\n   |                ------------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:31:5\n   |\n31 |     reveal_type(result)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: bytes [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:31:16\n   |\n31 |     reveal_type(result)\n   |                --------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:34:5\n   |\n34 |     reveal_type(result_direct)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: bytes [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:34:16\n   |\n34 |     reveal_type(result_direct)\n   |                ---------------\n   |\n\n[STDERR]\n INFO 3 errors",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:28: note: Revealed type is \"generated_examples.2025-12-13_22-33-38.source_files.protocol-call-positional-keyword.DataSerializer\"\ngenerated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:31: note: Revealed type is \"builtins.bytes\"\ngenerated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:34: note: Revealed type is \"builtins.bytes\"\nSuccess: no issues found in 1 source file",
                "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:28:5\n   |\n26 |     # Divergence point: assigning a function with positional-or-keyword args to a Protocol requiring keyword-only\n27 |     serializer: DataSerializer = serialize_to_bytes # Checkers disagree here\n28 |     reveal_type(serializer)\n   |     ^^^^^^^^^^^\n29 |\n30 |     result = serializer(data={\"name\": \"Alice\"}, format=\"json\") # This call itself would be valid at runtime\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:28:17\n   |\n26 |     # Divergence point: assigning a function with positional-or-keyword args to a Protocol requiring keyword-only\n27 |     serializer: DataSerializer = serialize_to_bytes # Checkers disagree here\n28 |     reveal_type(serializer)\n   |                 ^^^^^^^^^^ `def serialize_to_bytes(data: dict[str, Any], format: str = Literal[\"json\"]) -> bytes`\n29 |\n30 |     result = serializer(data={\"name\": \"Alice\"}, format=\"json\") # This call itself would be valid at runtime\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:31:5\n   |\n30 |     result = serializer(data={\"name\": \"Alice\"}, format=\"json\") # This call itself would be valid at runtime\n31 |     reveal_type(result)\n   |     ^^^^^^^^^^^\n32 |\n33 |     result_direct = serialize_to_bytes(data={\"id\": 123}, format=\"yaml\")\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:31:17\n   |\n30 |     result = serializer(data={\"name\": \"Alice\"}, format=\"json\") # This call itself would be valid at runtime\n31 |     reveal_type(result)\n   |                 ^^^^^^ `bytes`\n32 |\n33 |     result_direct = serialize_to_bytes(data={\"id\": 123}, format=\"yaml\")\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:34:5\n   |\n33 |     result_direct = serialize_to_bytes(data={\"id\": 123}, format=\"yaml\")\n34 |     reveal_type(result_direct)\n   |     ^^^^^^^^^^^\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/protocol-call-positional-keyword.py:34:17\n   |\n33 |     result_direct = serialize_to_bytes(data={\"id\": 123}, format=\"yaml\")\n34 |     reveal_type(result_direct)\n   |                 ^^^^^^^^^^^^^ `bytes`\n   |\n\nFound 6 diagnostics"
            }
        },
        {
            "filename": "overload-literal-discrimination.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:12: error: Overloaded function signatures 1 and 3 overlap with incompatible return types  [overload-overlap]\ngenerated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:14: error: Overloaded function signatures 2 and 3 overlap with incompatible return types  [overload-overlap]\ngenerated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:27: note: Revealed type is \"builtins.bool\"\ngenerated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:30: note: Revealed type is \"builtins.int\"\ngenerated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:33: note: Revealed type is \"builtins.str\"\nFound 2 errors in 1 file (checked 1 source file)",
                "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:27:5\n   |\n27 |     reveal_type(debug_val)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: bool [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:27:16\n   |\n27 |     reveal_type(debug_val)\n   |                -----------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:30:5\n   |\n30 |     reveal_type(retries_val)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: int [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:30:16\n   |\n30 |     reveal_type(retries_val)\n   |                -------------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:33:5\n   |\n33 |     reveal_type(other_val)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: str [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:33:16\n   |\n33 |     reveal_type(other_val)\n   |                -----------\n   |\n\n[STDERR]\n INFO 3 errors",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:27: note: Revealed type is \"builtins.bool\"\ngenerated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:30: note: Revealed type is \"builtins.int\"\ngenerated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:33: note: Revealed type is \"builtins.str\"\nSuccess: no issues found in 1 source file",
                "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:27:5\n   |\n25 | if __name__ == \"__main__\":\n26 |     debug_val = get_config_value(\"debug_mode\") # Checkers disagree on inferred type\n27 |     reveal_type(debug_val)\n   |     ^^^^^^^^^^^\n28 |\n29 |     retries_val = get_config_value(\"max_retries\") # Checkers disagree on inferred type\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:27:17\n   |\n25 | if __name__ == \"__main__\":\n26 |     debug_val = get_config_value(\"debug_mode\") # Checkers disagree on inferred type\n27 |     reveal_type(debug_val)\n   |                 ^^^^^^^^^ `bool`\n28 |\n29 |     retries_val = get_config_value(\"max_retries\") # Checkers disagree on inferred type\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:30:5\n   |\n29 |     retries_val = get_config_value(\"max_retries\") # Checkers disagree on inferred type\n30 |     reveal_type(retries_val)\n   |     ^^^^^^^^^^^\n31 |\n32 |     other_val = get_config_value(\"feature_x_enabled\") # Should be str for all\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:30:17\n   |\n29 |     retries_val = get_config_value(\"max_retries\") # Checkers disagree on inferred type\n30 |     reveal_type(retries_val)\n   |                 ^^^^^^^^^^^ `int`\n31 |\n32 |     other_val = get_config_value(\"feature_x_enabled\") # Should be str for all\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:33:5\n   |\n32 |     other_val = get_config_value(\"feature_x_enabled\") # Should be str for all\n33 |     reveal_type(other_val)\n   |     ^^^^^^^^^^^\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/overload-literal-discrimination.py:33:17\n   |\n32 |     other_val = get_config_value(\"feature_x_enabled\") # Should be str for all\n33 |     reveal_type(other_val)\n   |                 ^^^^^^^^^ `str`\n   |\n\nFound 6 diagnostics"
            }
        },
        {
            "filename": "double-bound-typevar-generics.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:35: error: Value of type variable \"T_Notifier\" of \"dispatch_event_notification\" cannot be \"Notifier[User]\"  [type-var]\ngenerated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:36: note: Revealed type is \"double-bound-typevar-generics.Notifier[double-bound-typevar-generics.User]\"\ngenerated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:40: error: Value of type variable \"T_Notifier\" of \"dispatch_event_notification\" cannot be \"Notifier[SystemLog]\"  [type-var]\nFound 2 errors in 1 file (checked 1 source file)",
                "pyrefly": "ERROR `Notifier[User]` is not assignable to upper bound `Notifier[Event]` of type variable `T_Notifier` [bad-specialization]\n  --> generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:35:32\n   |\n35 |     dispatch_event_notification(user_notifier, user) # Checkers disagree here\n   |                                ^^^^^^^^^^^^^^^^^^^^^\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:36:5\n   |\n36 |     reveal_type(user_notifier)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: Notifier[User] [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:36:16\n   |\n36 |     reveal_type(user_notifier)\n   |                ---------------\n   |\nERROR `Notifier[SystemLog]` is not assignable to upper bound `Notifier[Event]` of type variable `T_Notifier` [bad-specialization]\n  --> generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:40:32\n   |\n40 |     dispatch_event_notification(system_notifier, system_log)\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n\n[STDERR]\n INFO 3 errors",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:35: error: Value of type variable \"T_Notifier\" of \"dispatch_event_notification\" cannot be \"Notifier[User]\"  [type-var]\ngenerated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:36: note: Revealed type is \"generated_examples.2025-12-13_22-33-38.source_files.double-bound-typevar-generics.Notifier[generated_examples.2025-12-13_22-33-38.source_files.double-bound-typevar-generics.User]\"\ngenerated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:40: error: Value of type variable \"T_Notifier\" of \"dispatch_event_notification\" cannot be \"Notifier[SystemLog]\"  [type-var]\nFound 2 errors in 1 file (checked 1 source file)",
                "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:36:5\n   |\n34 |     # Mypy often complains here, as it upholds invariance strictly.\n35 |     dispatch_event_notification(user_notifier, user) # Checkers disagree here\n36 |     reveal_type(user_notifier)\n   |     ^^^^^^^^^^^\n37 |\n38 |     system_notifier: Notifier[SystemLog] = Notifier()\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/double-bound-typevar-generics.py:36:17\n   |\n34 |     # Mypy often complains here, as it upholds invariance strictly.\n35 |     dispatch_event_notification(user_notifier, user) # Checkers disagree here\n36 |     reveal_type(user_notifier)\n   |                 ^^^^^^^^^^^^^ `Notifier[Unknown]`\n37 |\n38 |     system_notifier: Notifier[SystemLog] = Notifier()\n   |\n\nFound 2 diagnostics"
            }
        },
        {
            "filename": "typeddict-mixed-total.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:20: note: Revealed type is \"builtins.str\"\ngenerated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:21: note: Revealed type is \"builtins.int | None\"\ngenerated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:22: note: Revealed type is \"builtins.str\"\ngenerated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:26: note: Revealed type is \"builtins.int\"\nSuccess: no issues found in 1 source file",
                "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:20:5\n   |\n20 |     reveal_type(td.get('host'))    # str for all\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: str [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:20:16\n   |\n20 |     reveal_type(td.get('host'))    # str for all\n   |                ----------------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:21:5\n   |\n21 |     reveal_type(td.get('port'))    # int | None for all\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: int | None [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:21:16\n   |\n21 |     reveal_type(td.get('port'))    # int | None for all\n   |                ----------------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:22:5\n   |\n22 |     reveal_type(td['protocol'])    # str for all\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: str [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:22:16\n   |\n22 |     reveal_type(td['protocol'])    # str for all\n   |                ----------------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:26:5\n   |\n26 |     reveal_type(p)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: int [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:26:16\n   |\n26 |     reveal_type(p)\n   |                ---\n   |\n\n[STDERR]\n INFO 4 errors",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:20: note: Revealed type is \"builtins.str | None\"\ngenerated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:21: note: Revealed type is \"builtins.int | None\"\ngenerated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:22: note: Revealed type is \"builtins.str\"\ngenerated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:26: note: Revealed type is \"builtins.int\"\nSuccess: no issues found in 1 source file",
                "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:20:5\n   |\n19 | def check_config(td: NetworkConfig) -> None:\n20 |     reveal_type(td.get('host'))    # str for all\n   |     ^^^^^^^^^^^\n21 |     reveal_type(td.get('port'))    # int | None for all\n22 |     reveal_type(td['protocol'])    # str for all\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:20:17\n   |\n19 | def check_config(td: NetworkConfig) -> None:\n20 |     reveal_type(td.get('host'))    # str for all\n   |                 ^^^^^^^^^^^^^^ `str`\n21 |     reveal_type(td.get('port'))    # int | None for all\n22 |     reveal_type(td['protocol'])    # str for all\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:21:5\n   |\n19 | def check_config(td: NetworkConfig) -> None:\n20 |     reveal_type(td.get('host'))    # str for all\n21 |     reveal_type(td.get('port'))    # int | None for all\n   |     ^^^^^^^^^^^\n22 |     reveal_type(td['protocol'])    # str for all\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:21:17\n   |\n19 | def check_config(td: NetworkConfig) -> None:\n20 |     reveal_type(td.get('host'))    # str for all\n21 |     reveal_type(td.get('port'))    # int | None for all\n   |                 ^^^^^^^^^^^^^^ `int | None`\n22 |     reveal_type(td['protocol'])    # str for all\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:22:5\n   |\n20 |     reveal_type(td.get('host'))    # str for all\n21 |     reveal_type(td.get('port'))    # int | None for all\n22 |     reveal_type(td['protocol'])    # str for all\n   |     ^^^^^^^^^^^\n23 |     \n24 |     # This is the point of divergence for direct access to NotRequired keys\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:22:17\n   |\n20 |     reveal_type(td.get('host'))    # str for all\n21 |     reveal_type(td.get('port'))    # int | None for all\n22 |     reveal_type(td['protocol'])    # str for all\n   |                 ^^^^^^^^^^^^^^ `str`\n23 |     \n24 |     # This is the point of divergence for direct access to NotRequired keys\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:26:5\n   |\n24 |     # This is the point of divergence for direct access to NotRequired keys\n25 |     p = td['port'] # Mypy typically errors here. Others infer int | None.\n26 |     reveal_type(p)\n   |     ^^^^^^^^^^^\n27 |\n28 | if __name__ == \"__main__\":\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeddict-mixed-total.py:26:17\n   |\n24 |     # This is the point of divergence for direct access to NotRequired keys\n25 |     p = td['port'] # Mypy typically errors here. Others infer int | None.\n26 |     reveal_type(p)\n   |                 ^ `int`\n27 |\n28 | if __name__ == \"__main__\":\n   |\n\nFound 8 diagnostics"
            }
        },
        {
            "filename": "typeguard-generic-narrowing.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/typeguard-generic-narrowing.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/typeguard-generic-narrowing.py:21: note: Revealed type is \"builtins.list[builtins.int]\"\nSuccess: no issues found in 1 source file",
                "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeguard-generic-narrowing.py:21:9\n   |\n21 |         reveal_type(items)\n   |         ^^^^^^^^^^^\n   |\n INFO revealed type: list[int] [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeguard-generic-narrowing.py:21:20\n   |\n21 |         reveal_type(items)\n   |                    -------\n   |\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/typeguard-generic-narrowing.py:21: note: Revealed type is \"builtins.list[builtins.int]\"\nSuccess: no issues found in 1 source file",
                "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeguard-generic-narrowing.py:21:9\n   |\n19 |         # After narrowing, 'items' should be list[int]\n20 |         items.append(123)  # Mypy might complain here\n21 |         reveal_type(items)\n   |         ^^^^^^^^^^^\n22 |     else:\n23 |         items.append(\"fallback\")\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/typeguard-generic-narrowing.py:21:21\n   |\n19 |         # After narrowing, 'items' should be list[int]\n20 |         items.append(123)  # Mypy might complain here\n21 |         reveal_type(items)\n   |                     ^^^^^ `list[Any]`\n22 |     else:\n23 |         items.append(\"fallback\")\n   |\n\nFound 2 diagnostics"
            }
        },
        {
            "filename": "protocol-default-args-mismatch.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/protocol-default-args-mismatch.py",
            "outputs": {
                "mypy": "Success: no issues found in 1 source file",
                "pyrefly": "[STDERR]\n INFO 0 errors",
                "zuban": "Success: no issues found in 1 source file",
                "ty": "All checks passed!"
            }
        },
        {
            "filename": "self-in-generics-abstract.py",
            "filepath": "generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py",
            "outputs": {
                "mypy": "generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:41: note: Revealed type is \"self-in-generics-abstract.StringAppender\"\ngenerated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:42: note: Revealed type is \"builtins.str\"\nSuccess: no issues found in 1 source file",
                "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:41:5\n   |\n41 |     reveal_type(builder)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: StringAppender [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:41:16\n   |\n41 |     reveal_type(builder)\n   |                ---------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:42:5\n   |\n42 |     reveal_type(result)\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: str [reveal-type]\n  --> generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:42:16\n   |\n42 |     reveal_type(result)\n   |                --------\n   |\n\n[STDERR]\n INFO 2 errors",
                "zuban": "generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:41: note: Revealed type is \"generated_examples.2025-12-13_22-33-38.source_files.self-in-generics-abstract.StringAppender\"\ngenerated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:42: note: Revealed type is \"builtins.str\"\nSuccess: no issues found in 1 source file",
                "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:41:5\n   |\n39 |     builder = StringAppender().add_item(\"Hello\").add_item(\" World\")\n40 |     result = builder.build()\n41 |     reveal_type(builder)\n   |     ^^^^^^^^^^^\n42 |     reveal_type(result)\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:41:17\n   |\n39 |     builder = StringAppender().add_item(\"Hello\").add_item(\" World\")\n40 |     result = builder.build()\n41 |     reveal_type(builder)\n   |                 ^^^^^^^ `StringAppender`\n42 |     reveal_type(result)\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:42:5\n   |\n40 |     result = builder.build()\n41 |     reveal_type(builder)\n42 |     reveal_type(result)\n   |     ^^^^^^^^^^^\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2025-12-13_22-33-38/source_files/self-in-generics-abstract.py:42:17\n   |\n40 |     result = builder.build()\n41 |     reveal_type(builder)\n42 |     reveal_type(result)\n   |                 ^^^^^^ `str`\n   |\n\nFound 4 diagnostics"
            }
        }
    ]
}