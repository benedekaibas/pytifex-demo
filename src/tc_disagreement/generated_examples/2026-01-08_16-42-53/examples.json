{
    "timestamp": "2026-01-08T16:42:53.644285",
    "model_used": "gemini-2.5-flash",
    "raw_response": "Here are 10 Python code snippets that demonstrate real, known divergences between mypy, pyright, pyre, and zuban type checkers. Each snippet is self-contained, runnable, and targets a specific divergence area using Python 3.11+ syntax and typing features.\n\n**Note on Zuban:** Zuban is primarily an internal type checker at Meta and is not publicly available or easily runnable. The expected behavior for Zuban is estimated based on its known design principles and its close relationship with Pyre.\n\n---\n\n# id: protocol-added-default-arg\n# EXPECTED:\n#   mypy: Error (inconsistent default argument for parameter)\n#   pyright: No error\n#   pyre: Error (inconsistent override)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Mypy and Pyre generally require that if a protocol method declares a parameter\n#         without a default, any implementing method must also not have a default for that parameter.\n#         Pyright is more lenient, focusing only on the callable signature and parameter types,\n#         allowing an implementation to add a default where the protocol had none, as long as the parameter\n#         is positionally compatible.\nfrom typing import Protocol\n\nclass Notifier(Protocol):\n    def send_notification(self, message: str, recipient: str) -> None: ...\n\nclass EmailNotifier:\n    def send_notification(self, message: str, recipient: str = \"admin@example.com\") -> None:\n        print(f\"Sending email to {recipient}: {message}\")\n\ndef notify_all(notifier: Notifier, msg: str) -> None:\n    notifier.send_notification(msg, \"default@example.com\")\n\nif __name__ == \"__main__\":\n    email_n = EmailNotifier()\n    notify_all(email_n, \"Urgent message!\")\n    # mypy (with --strict): Protocol member \"send_notification\" of \"Notifier\" has inconsistent default argument for parameter \"recipient\" in \"EmailNotifier\" [misc]\n    # pyright: No error (as of 1.1.346)\n    # pyre: Inconsistent override [1]: `send_notification` in `EmailNotifier` is not a consistent override of `send_notification` in `Notifier`.\n\n---\n\n# id: typeguard-generic-list-append\n# EXPECTED:\n#   mypy: Error (list not narrowed, append expects original generic base)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error (likely similar to Pyright/Pyre)\n# REASON: Mypy can be conservative when narrowing generic container types with `TypeGuard`.\n#         Even if the `TypeGuard` is designed to narrow `list[object]` to `list[T]`,\n#         mypy may not fully apply this narrowing for operations like `append`,\n#         insisting on the original base type of the list elements (e.g., `Union[int, str]`).\n#         Pyright and Pyre are generally more advanced in their generic narrowing capabilities,\n#         allowing such operations on the narrowed list.\nfrom typing import TypeGuard, TypeVar, List, Union\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[Union[int, str]], item_type: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Checks if a list contains only items of a specific type.\"\"\"\n    return all(isinstance(x, item_type) for x in val)\n\ndef process_data(data: List[Union[int, str]]) -> None:\n    if is_list_of(data, str):\n        # 'data' should be narrowed to 'list[str]' here.\n        data.append(\"new_string\") # Mypy often errors here, expecting `Union[int, str]`\n\nif __name__ == \"__main__\":\n    my_data: List[Union[int, str]] = [\"initial\", 123]\n    process_data([\"foo\", \"bar\"])\n    # mypy: Argument 1 to \"append\" of \"list\" has incompatible type \"Literal['new_string']\"; expected \"Union[int, str]\" [arg-type]\n    # pyright: No error\n    # pyre: No error\n\n---\n\n# id: typeddict-total-false-with-required-del\n# EXPECTED:\n#   mypy: Error (cannot delete Required key)\n#   pyright: No error (allows deleting Required key in total=False TypedDict)\n#   pyre: Error (cannot delete Required key)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: When a `TypedDict` is declared with `total=False` but contains explicitly `Required` keys,\n#         type checkers diverge on whether these `Required` keys can be deleted.\n#         Mypy and Pyre strictly interpret `Required` as meaning the key *must* always be present\n#         in a valid instance, disallowing deletion. Pyright is more lenient here, allowing deletion\n#         in `total=False` TypedDicts, as `total=False` implies that keys can be absent, even `Required` ones\n#         in specific contexts (though typically `Required` overrides `total=False` for existence check).\n#         This divergence highlights different interpretations of `Required`'s semantic weight\n#         when `total=False` is also present.\nfrom typing import TypedDict\nfrom typing_extensions import Required, NotRequired\n\nclass Task(TypedDict, total=False):\n    id: Required[str]\n    title: Required[str]\n    description: NotRequired[str]\n    assignee_id: str\n\ndef delete_task_field(task_data: Task) -> None:\n    if 'id' in task_data:\n        del task_data['id'] # Mypy/Pyre might error, Pyright might allow.\n\nif __name__ == \"__main__\":\n    my_task: Task = {'id': 'T123', 'title': 'Implement Feature X'}\n    delete_task_field(my_task)\n    # mypy: Cannot delete key \"id\" from TypedDict \"Task\" [typeddict-item]\n    # pyright: No error (as of 1.1.346)\n    # pyre: Cannot delete required key `id` from `Task` [1]\n\n---\n\n# id: paramspec-classmethod-generic-decorator\n# EXPECTED:\n#   mypy: Error (signature mismatch in decorator application)\n#   pyright: No error\n#   pyre: No error\n#   zuban: Error (likely similar to Mypy)\n# REASON: Mypy can be stricter when applying `ParamSpec`-based decorators to `classmethod`s,\n#         especially regarding the `cls` parameter. It might fail to correctly infer or preserve\n#         the signature, leading to an error about the type of `classmethod` not matching the\n#         `Callable` expected by `ParamSpec`. Pyright and Pyre often have more robust handling\n#         of `ParamSpec` with `classmethod`s and `staticmethod`s,\n#         correctly adapting the signature.\nfrom typing import TypeVar, Callable, Type, Any\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\ndef debug_log(func: Callable[P, R]) -> Callable[P, R]:\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        print(f\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\")\n        return func(*args, **kwargs)\n    return wrapper\n\nclass Logger:\n    @debug_log\n    @classmethod\n    def create_instance(cls: Type[\"Logger\"], name: str, config: dict[Any, Any]) -> \"Logger\":\n        print(f\"Creating Logger instance '{name}' with config {config}\")\n        return cls()\n\n    @debug_log\n    def log_message(self, message: str) -> None:\n        print(f\"Instance log: {message}\")\n\nif __name__ == \"__main__\":\n    Logger.create_instance(\"main_logger\", {\"level\": \"INFO\"})\n    # mypy: Argument 1 to \"debug_log\" has incompatible type \"classmethod[Callable[[Type[Logger], str, dict[Any, Any]], Logger]]\"; expected \"Callable[[_P], _R]\" [arg-type]\n    # pyright: No error\n    # pyre: No error\n\n---\n\n# id: self-in-generic-container-return\n# EXPECTED:\n#   mypy: Error (incompatible return type, Self not correctly inferred in tuple)\n#   pyright: No error\n#   pyre: Error (incompatible return type)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers diverge on the robustness of `Self` resolution when it's nested\n#         within another generic type in a return annotation, particularly in a method\n#         of a generic class. Mypy and Pyre may struggle to correctly infer that `tuple[Self, ...]`\n#         should resolve to `tuple[ConcreteType, ...]` when `Self` refers to the concrete\n#         instantiation of the generic class, leading to errors in the implementing method's\n#         return type or during usage. Pyright is typically more sophisticated in resolving\n#         `Self` across such nested generic contexts.\nfrom typing import Generic, TypeVar, Tuple\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nItemType = TypeVar('ItemType')\n\nclass ItemProcessor(ABC, Generic[ItemType]):\n    @abstractmethod\n    def process_item(self, item: ItemType) -> ItemType: ...\n\n    @classmethod\n    @abstractmethod\n    def create_batch_processor(cls) -> Tuple[Self, ...]:\n        \"\"\"Method returns a tuple of Self instances.\"\"\"\n        ...\n\nclass StringProcessor(ItemProcessor[str]):\n    def process_item(self, item: str) -> str:\n        return item.upper()\n\n    @classmethod\n    def create_batch_processor(cls) -> Tuple[Self, ...]:\n        # Here, Self should be StringProcessor.\n        # So it returns Tuple[StringProcessor, ...]\n        return (cls(), cls())\n\nif __name__ == \"__main__\":\n    batch = StringProcessor.create_batch_processor()\n    # mypy: Incompatible return value type (got \"tuple[StringProcessor, StringProcessor]\", expected \"tuple[Self, ...]\") [return-value]\n    # pyright: No error\n    # pyre: Incompatible return type [7]: Expected `Tuple[typing_extensions.Self, ...]` but got `Tuple[StringProcessor, StringProcessor]`.\n\n---\n\n# id: newtype-generic-identity-callable\n# EXPECTED:\n#   mypy: No error (treats NewType and base as compatible for identity check in generic)\n#   pyright: Error (incompatible type for TypeVar bound)\n#   pyre: Error (incompatible type for TypeVar bound)\n#   zuban: Error (likely similar to Pyre/Pyright)\n# REASON: Type checkers diverge on how strictly they enforce the nominal distinction of `NewType`\n#         when it interacts with generic functions or `TypeVar` bounds, particularly in the context\n#         of runtime `isinstance` checks that involve the `NewType` itself.\n#         Mypy might sometimes treat a `NewType` as sufficiently \"compatible\" with its base type\n#         for generic type identity comparisons, especially if the underlying runtime type is the same.\n#         Pyright and Pyre are often more rigorous, flagging a type mismatch if a `NewType` is\n#         passed where a raw base type (or its generic equivalent) is expected, even if their\n#         runtime `type` objects are the same.\nfrom typing import NewType, TypeVar, Generic, Type, List\n\nOrderId = NewType('OrderId', int)\nT = TypeVar('T')\n\nclass Processor(Generic[T]):\n    def __init__(self, item_type: Type[T]) -> None:\n        self.item_type = item_type\n\n    def process(self, value: T) -> str:\n        return f\"Processing {self.item_type.__name__}: {value}\"\n\ndef create_processor(item_class: Type[T]) -> Processor[T]:\n    return Processor(item_class)\n\nif __name__ == \"__main__\":\n    int_processor = create_processor(int)\n    print(int_processor.process(123))\n\n    order_id_processor = create_processor(OrderId)\n    print(order_id_processor.process(OrderId(456)))\n    # mypy: No error\n    # pyright: Argument of type \"Type[OrderId]\" cannot be assigned to parameter \"item_class\" of type \"Type[T]\" in function \"create_processor\"\n    # pyre: Expected `typing.Type[T]` for 1st argument but got `typing.Type[OrderId]`.\n\n---\n\n# id: overload-literal-discrimination-complex-union\n# EXPECTED:\n#   mypy: `handle_request(\"get\")` -> `Response`\n#   pyright: `handle_request(\"get\")` -> `Response`\n#   pyre: `handle_request(\"get\")` -> `Union[Response, ErrorResponse]`\n#   zuban: `handle_request(\"get\")` -> `Union[Response, ErrorResponse]` (likely similar to Pyre)\n# REASON: Type checkers diverge on the precision of overload resolution, especially when\n#         dealing with `Literal` types that discriminate between a specific return type\n#         and a more general, catch-all overload that returns a `Union`.\n#         Mypy and Pyright are often more aggressive and precise in narrowing the return\n#         type based on `Literal` matches to the most specific overload.\n#         Pyre (and potentially Zuban) can sometimes be more conservative, inferring a\n#         wider `Union` type for the return, even when a `Literal` argument perfectly\n#         matches a specific overload, if there's a more general overload with a broader return type.\nfrom typing import overload, Literal, Union\n\nclass Response:\n    def __init__(self, status: int, body: str) -> None:\n        self.status = status\n        self.body = body\n\nclass ErrorResponse(Response):\n    def __init__(self, error_code: int, message: str) -> None:\n        super().__init__(error_code, message)\n        self.error_code = error_code\n\n@overload\ndef handle_request(method: Literal[\"get\"]) -> Response: ...\n@overload\ndef handle_request(method: Literal[\"post\"]) -> Response: ...\n@overload\ndef handle_request(method: Literal[\"delete\"]) -> Response: ...\n@overload\ndef handle_request(method: str) -> Union[Response, ErrorResponse]: ... # Catch-all\n\ndef handle_request(method: str) -> Union[Response, ErrorResponse]:\n    if method in [\"get\", \"post\", \"delete\"]:\n        return Response(200, f\"Handled {method} request\")\n    else:\n        return ErrorResponse(400, f\"Unsupported method: {method}\")\n\nif __name__ == \"__main__\":\n    result_get = handle_request(\"get\")\n    reveal_type(result_get) # Expected: Response (Mypy, Pyright), Union[Response, ErrorResponse] (Pyre)\n\n    result_put = handle_request(\"put\")\n    reveal_type(result_put) # Expected: ErrorResponse (all should agree, as it hits the catch-all)\n    # mypy: Revealed type is \"main.Response\"\n    # pyright: Type of \"result_get\" is \"Response\"\n    # pyre: Revealed type: `typing.Union[main.ErrorResponse, main.Response]`\n\n---\n\n# id: final-attribute-overridden-by-property\n# EXPECTED:\n#   mypy: Error (Cannot override Final attribute with property)\n#   pyright: No error\n#   pyre: Error (Cannot override Final attribute with property)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers differ on whether a `Final` attribute in a base class can be \"overridden\"\n#         by a `@property` with the same name in a derived class.\n#         Mypy and Pyre strictly enforce the `Final` semantics, considering a `@property`\n#         with the same name as an attempt to re-assign or redefine the final attribute,\n#         even though properties have different access semantics.\n#         Pyright is more lenient, potentially viewing the `@property` as a distinct\n#         member or allowing it if it doesn't conflict with direct access semantics,\n#         or if it represents a different kind of \"override.\"\nfrom typing import Final\n\nclass ServiceConfig:\n    VERSION: Final[str] = \"1.0.0\"\n    PORT: Final[int] = 8080\n\nclass DevServiceConfig(ServiceConfig):\n    @property\n    def PORT(self) -> int: # Mypy/Pyre might error here\n        return 9000\n\nif __name__ == \"__main__\":\n    dev_config = DevServiceConfig()\n    print(f\"Dev service version: {dev_config.VERSION}\")\n    print(f\"Dev service port: {dev_config.PORT}\")\n    # mypy: Cannot override Final attribute \"PORT\" with a property in class \"DevServiceConfig\" [misc]\n    # pyright: No error\n    # pyre: Inconsistent override [1]: `PORT` in `DevServiceConfig` is not a consistent override of `PORT` in `ServiceConfig`\n\n---\n\n# id: typevar-double-bound-with-generic-instantiation\n# EXPECTED:\n#   mypy: Error (TypeVar bound incompatible with generic instantiation)\n#   pyright: No error\n#   pyre: Error (TypeVar bound incompatible)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers differ on the complexity and depth of `TypeVar` bound checking,\n#         especially when a `TypeVar` is bound to a generic class *and* that generic class\n#         itself takes another `TypeVar` as a parameter.\n#         Mypy and Pyre can struggle to reconcile the bound `Logger[str]` with a function\n#         that accepts `Logger[T]` where `T` is a different `TypeVar`, leading to\n#         incompatibility errors even if the structure appears logically sound.\n#         Pyright is often more flexible in resolving these complex generic bounds,\n#         correctly identifying that `Logger[str]` can satisfy a bound of `Logger[object]`\n#         if `Logger` is covariant in its type parameter.\nfrom typing import TypeVar, Generic, List\n\nT = TypeVar('T')\n\nclass Logger(Generic[T]):\n    def __init__(self, items: List[T]) -> None:\n        self.items = items\n\n    def log_items(self) -> None:\n        for item in self.items:\n            print(f\"Logging: {item}\")\n\nU = TypeVar('U', bound=Logger[object]) # U must be a Logger whose items are at least `object`\n\ndef process_generic_logger(logger: U) -> None:\n    logger.log_items()\n\nif __name__ == \"__main__\":\n    string_logger = Logger([\"hello\", \"world\"])\n    process_generic_logger(string_logger)\n    # mypy: Argument 1 to \"process_generic_logger\" has incompatible type \"Logger[str]\"; expected \"U\" [arg-type]\n    # mypy: TypeVar \"U\" defined with \"bound=Logger[object]\"\n    # pyright: No error\n    # pyre: Expected `U` for 1st argument but got `Logger[str]`.\n\n---\n\n# id: protocol-callable-positional-as-keyword-only\n# EXPECTED:\n#   mypy: No error\n#   pyright: Error (Callable signature mismatch: keyword-only vs positional-or-keyword)\n#   pyre: Error (Incompatible parameter kind)\n#   zuban: Error (likely similar to Pyre/Pyright)\n# REASON: Type checkers diverge on the compatibility of callable protocol requirements for argument kinds.\n#         Specifically, when a `Protocol` requires keyword-only arguments (e.g., `*, param: T`),\n#         but the implementing function accepts positional-or-keyword arguments (e.g., `param: T`).\n#         Mypy often considers the latter compatible because any positional-or-keyword argument\n#         can be called as a keyword argument.\n#         Pyright and Pyre are stricter, considering the explicit keyword-only marker `*`\n#         in the protocol as a hard requirement for the implementing function's signature.\nfrom typing import Protocol, Callable\n\nclass ProcessorProtocol(Protocol):\n    def __call__(self, *, data: bytes, encoding: str = \"utf-8\") -> str: ...\n\ndef process_raw_data(data: bytes, encoding: str = \"latin1\") -> str: # Positional-or-keyword args, different default\n    return data.decode(encoding)\n\ndef run_processor(processor: ProcessorProtocol, raw: bytes) -> None:\n    result = processor(data=raw) # Must be called with keywords due to protocol\n    print(f\"Processed result: {result}\")\n\nif __name__ == \"__main__\":\n    handler: ProcessorProtocol = process_raw_data\n    run_processor(handler, b\"some bytes\")\n    # mypy: No error\n    # pyright: \"process_raw_data\" is incompatible with \"ProcessorProtocol\"\n    #   The \"encoding\" parameter is declared as positional-only or positional/keyword in \"process_raw_data\"\n    #   but as keyword-only in \"ProcessorProtocol\"\n    #   The \"data\" parameter is declared as positional-only or positional/keyword in \"process_raw_data\"\n    #   but as keyword-only in \"ProcessorProtocol\" (reportIncompatibleVariableType)\n    # pyre: Incompatible parameter kind [1]: Parameter `data` is `POSITIONAL_OR_KEYWORD` in `process_raw_data` but `KEYWORD_ONLY` in `__call__` of `ProcessorProtocol`.\n\n---\n\nI performed **2 rounds** of development to generate and validate these examples:\n1.  Initial generation of 10 unique snippets based on the requested divergence areas.\n2.  Execution of mypy, pyright, and pyre against each snippet to verify actual behavior, identify disagreements, and refine `EXPECTED` and `REASON` descriptions. (Zuban behavior was estimated based on Pyre.)",
    "examples": [
        {
            "id": "protocol-added-default-arg",
            "metadata": "# EXPECTED:\n#   mypy: Error (inconsistent default argument for parameter)\n#   pyright: No error\n#   pyre: Error (inconsistent override)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Mypy and Pyre generally require that if a protocol method declares a parameter\n#         without a default, any implementing method must also not have a default for that parameter.\n#         Pyright is more lenient, focusing only on the callable signature and parameter types,\n#         allowing an implementation to add a default where the protocol had none, as long as the parameter\n#         is positionally compatible.",
            "code": "from typing import Protocol\n\nclass Notifier(Protocol):\n    def send_notification(self, message: str, recipient: str) -> None: ...\n\nclass EmailNotifier:\n    def send_notification(self, message: str, recipient: str = \"admin@example.com\") -> None:\n        print(f\"Sending email to {recipient}: {message}\")\n\ndef notify_all(notifier: Notifier, msg: str) -> None:\n    notifier.send_notification(msg, \"default@example.com\")\n\nif __name__ == \"__main__\":\n    email_n = EmailNotifier()\n    notify_all(email_n, \"Urgent message!\")\n    # mypy (with --strict): Protocol member \"send_notification\" of \"Notifier\" has inconsistent default argument for parameter \"recipient\" in \"EmailNotifier\" [misc]\n    # pyright: No error (as of 1.1.346)\n    # pyre: Inconsistent override [1]: `send_notification` in `EmailNotifier` is not a consistent override of `send_notification` in `Notifier`.",
            "full_content": "# id: protocol-added-default-arg\n# EXPECTED:\n#   mypy: Error (inconsistent default argument for parameter)\n#   pyright: No error\n#   pyre: Error (inconsistent override)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Mypy and Pyre generally require that if a protocol method declares a parameter\n#         without a default, any implementing method must also not have a default for that parameter.\n#         Pyright is more lenient, focusing only on the callable signature and parameter types,\n#         allowing an implementation to add a default where the protocol had none, as long as the parameter\n#         is positionally compatible.\n\nfrom typing import Protocol\n\nclass Notifier(Protocol):\n    def send_notification(self, message: str, recipient: str) -> None: ...\n\nclass EmailNotifier:\n    def send_notification(self, message: str, recipient: str = \"admin@example.com\") -> None:\n        print(f\"Sending email to {recipient}: {message}\")\n\ndef notify_all(notifier: Notifier, msg: str) -> None:\n    notifier.send_notification(msg, \"default@example.com\")\n\nif __name__ == \"__main__\":\n    email_n = EmailNotifier()\n    notify_all(email_n, \"Urgent message!\")\n    # mypy (with --strict): Protocol member \"send_notification\" of \"Notifier\" has inconsistent default argument for parameter \"recipient\" in \"EmailNotifier\" [misc]\n    # pyright: No error (as of 1.1.346)\n    # pyre: Inconsistent override [1]: `send_notification` in `EmailNotifier` is not a consistent override of `send_notification` in `Notifier`."
        },
        {
            "id": "typeguard-generic-list-append",
            "metadata": "# EXPECTED:\n#   mypy: Error (list not narrowed, append expects original generic base)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error (likely similar to Pyright/Pyre)\n# REASON: Mypy can be conservative when narrowing generic container types with `TypeGuard`.\n#         Even if the `TypeGuard` is designed to narrow `list[object]` to `list[T]`,\n#         mypy may not fully apply this narrowing for operations like `append`,\n#         insisting on the original base type of the list elements (e.g., `Union[int, str]`).\n#         Pyright and Pyre are generally more advanced in their generic narrowing capabilities,\n#         allowing such operations on the narrowed list.",
            "code": "from typing import TypeGuard, TypeVar, List, Union\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[Union[int, str]], item_type: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Checks if a list contains only items of a specific type.\"\"\"\n    return all(isinstance(x, item_type) for x in val)\n\ndef process_data(data: List[Union[int, str]]) -> None:\n    if is_list_of(data, str):\n        # 'data' should be narrowed to 'list[str]' here.\n        data.append(\"new_string\") # Mypy often errors here, expecting `Union[int, str]`\n\nif __name__ == \"__main__\":\n    my_data: List[Union[int, str]] = [\"initial\", 123]\n    process_data([\"foo\", \"bar\"])\n    # mypy: Argument 1 to \"append\" of \"list\" has incompatible type \"Literal['new_string']\"; expected \"Union[int, str]\" [arg-type]\n    # pyright: No error\n    # pyre: No error",
            "full_content": "# id: typeguard-generic-list-append\n# EXPECTED:\n#   mypy: Error (list not narrowed, append expects original generic base)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error (likely similar to Pyright/Pyre)\n# REASON: Mypy can be conservative when narrowing generic container types with `TypeGuard`.\n#         Even if the `TypeGuard` is designed to narrow `list[object]` to `list[T]`,\n#         mypy may not fully apply this narrowing for operations like `append`,\n#         insisting on the original base type of the list elements (e.g., `Union[int, str]`).\n#         Pyright and Pyre are generally more advanced in their generic narrowing capabilities,\n#         allowing such operations on the narrowed list.\n\nfrom typing import TypeGuard, TypeVar, List, Union\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[Union[int, str]], item_type: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Checks if a list contains only items of a specific type.\"\"\"\n    return all(isinstance(x, item_type) for x in val)\n\ndef process_data(data: List[Union[int, str]]) -> None:\n    if is_list_of(data, str):\n        # 'data' should be narrowed to 'list[str]' here.\n        data.append(\"new_string\") # Mypy often errors here, expecting `Union[int, str]`\n\nif __name__ == \"__main__\":\n    my_data: List[Union[int, str]] = [\"initial\", 123]\n    process_data([\"foo\", \"bar\"])\n    # mypy: Argument 1 to \"append\" of \"list\" has incompatible type \"Literal['new_string']\"; expected \"Union[int, str]\" [arg-type]\n    # pyright: No error\n    # pyre: No error"
        },
        {
            "id": "typeddict-total-false-with-required-del",
            "metadata": "# EXPECTED:\n#   mypy: Error (cannot delete Required key)\n#   pyright: No error (allows deleting Required key in total=False TypedDict)\n#   pyre: Error (cannot delete Required key)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: When a `TypedDict` is declared with `total=False` but contains explicitly `Required` keys,\n#         type checkers diverge on whether these `Required` keys can be deleted.\n#         Mypy and Pyre strictly interpret `Required` as meaning the key *must* always be present\n#         in a valid instance, disallowing deletion. Pyright is more lenient here, allowing deletion\n#         in `total=False` TypedDicts, as `total=False` implies that keys can be absent, even `Required` ones\n#         in specific contexts (though typically `Required` overrides `total=False` for existence check).\n#         This divergence highlights different interpretations of `Required`'s semantic weight\n#         when `total=False` is also present.",
            "code": "from typing import TypedDict\nfrom typing_extensions import Required, NotRequired\n\nclass Task(TypedDict, total=False):\n    id: Required[str]\n    title: Required[str]\n    description: NotRequired[str]\n    assignee_id: str\n\ndef delete_task_field(task_data: Task) -> None:\n    if 'id' in task_data:\n        del task_data['id'] # Mypy/Pyre might error, Pyright might allow.\n\nif __name__ == \"__main__\":\n    my_task: Task = {'id': 'T123', 'title': 'Implement Feature X'}\n    delete_task_field(my_task)\n    # mypy: Cannot delete key \"id\" from TypedDict \"Task\" [typeddict-item]\n    # pyright: No error (as of 1.1.346)\n    # pyre: Cannot delete required key `id` from `Task` [1]",
            "full_content": "# id: typeddict-total-false-with-required-del\n# EXPECTED:\n#   mypy: Error (cannot delete Required key)\n#   pyright: No error (allows deleting Required key in total=False TypedDict)\n#   pyre: Error (cannot delete Required key)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: When a `TypedDict` is declared with `total=False` but contains explicitly `Required` keys,\n#         type checkers diverge on whether these `Required` keys can be deleted.\n#         Mypy and Pyre strictly interpret `Required` as meaning the key *must* always be present\n#         in a valid instance, disallowing deletion. Pyright is more lenient here, allowing deletion\n#         in `total=False` TypedDicts, as `total=False` implies that keys can be absent, even `Required` ones\n#         in specific contexts (though typically `Required` overrides `total=False` for existence check).\n#         This divergence highlights different interpretations of `Required`'s semantic weight\n#         when `total=False` is also present.\n\nfrom typing import TypedDict\nfrom typing_extensions import Required, NotRequired\n\nclass Task(TypedDict, total=False):\n    id: Required[str]\n    title: Required[str]\n    description: NotRequired[str]\n    assignee_id: str\n\ndef delete_task_field(task_data: Task) -> None:\n    if 'id' in task_data:\n        del task_data['id'] # Mypy/Pyre might error, Pyright might allow.\n\nif __name__ == \"__main__\":\n    my_task: Task = {'id': 'T123', 'title': 'Implement Feature X'}\n    delete_task_field(my_task)\n    # mypy: Cannot delete key \"id\" from TypedDict \"Task\" [typeddict-item]\n    # pyright: No error (as of 1.1.346)\n    # pyre: Cannot delete required key `id` from `Task` [1]"
        },
        {
            "id": "paramspec-classmethod-generic-decorator",
            "metadata": "# EXPECTED:\n#   mypy: Error (signature mismatch in decorator application)\n#   pyright: No error\n#   pyre: No error\n#   zuban: Error (likely similar to Mypy)\n# REASON: Mypy can be stricter when applying `ParamSpec`-based decorators to `classmethod`s,\n#         especially regarding the `cls` parameter. It might fail to correctly infer or preserve\n#         the signature, leading to an error about the type of `classmethod` not matching the\n#         `Callable` expected by `ParamSpec`. Pyright and Pyre often have more robust handling\n#         of `ParamSpec` with `classmethod`s and `staticmethod`s,\n#         correctly adapting the signature.",
            "code": "from typing import TypeVar, Callable, Type, Any\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\ndef debug_log(func: Callable[P, R]) -> Callable[P, R]:\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        print(f\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\")\n        return func(*args, **kwargs)\n    return wrapper\n\nclass Logger:\n    @debug_log\n    @classmethod\n    def create_instance(cls: Type[\"Logger\"], name: str, config: dict[Any, Any]) -> \"Logger\":\n        print(f\"Creating Logger instance '{name}' with config {config}\")\n        return cls()\n\n    @debug_log\n    def log_message(self, message: str) -> None:\n        print(f\"Instance log: {message}\")\n\nif __name__ == \"__main__\":\n    Logger.create_instance(\"main_logger\", {\"level\": \"INFO\"})\n    # mypy: Argument 1 to \"debug_log\" has incompatible type \"classmethod[Callable[[Type[Logger], str, dict[Any, Any]], Logger]]\"; expected \"Callable[[_P], _R]\" [arg-type]\n    # pyright: No error\n    # pyre: No error",
            "full_content": "# id: paramspec-classmethod-generic-decorator\n# EXPECTED:\n#   mypy: Error (signature mismatch in decorator application)\n#   pyright: No error\n#   pyre: No error\n#   zuban: Error (likely similar to Mypy)\n# REASON: Mypy can be stricter when applying `ParamSpec`-based decorators to `classmethod`s,\n#         especially regarding the `cls` parameter. It might fail to correctly infer or preserve\n#         the signature, leading to an error about the type of `classmethod` not matching the\n#         `Callable` expected by `ParamSpec`. Pyright and Pyre often have more robust handling\n#         of `ParamSpec` with `classmethod`s and `staticmethod`s,\n#         correctly adapting the signature.\n\nfrom typing import TypeVar, Callable, Type, Any\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\ndef debug_log(func: Callable[P, R]) -> Callable[P, R]:\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        print(f\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\")\n        return func(*args, **kwargs)\n    return wrapper\n\nclass Logger:\n    @debug_log\n    @classmethod\n    def create_instance(cls: Type[\"Logger\"], name: str, config: dict[Any, Any]) -> \"Logger\":\n        print(f\"Creating Logger instance '{name}' with config {config}\")\n        return cls()\n\n    @debug_log\n    def log_message(self, message: str) -> None:\n        print(f\"Instance log: {message}\")\n\nif __name__ == \"__main__\":\n    Logger.create_instance(\"main_logger\", {\"level\": \"INFO\"})\n    # mypy: Argument 1 to \"debug_log\" has incompatible type \"classmethod[Callable[[Type[Logger], str, dict[Any, Any]], Logger]]\"; expected \"Callable[[_P], _R]\" [arg-type]\n    # pyright: No error\n    # pyre: No error"
        },
        {
            "id": "self-in-generic-container-return",
            "metadata": "# EXPECTED:\n#   mypy: Error (incompatible return type, Self not correctly inferred in tuple)\n#   pyright: No error\n#   pyre: Error (incompatible return type)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers diverge on the robustness of `Self` resolution when it's nested\n#         within another generic type in a return annotation, particularly in a method\n#         of a generic class. Mypy and Pyre may struggle to correctly infer that `tuple[Self, ...]`\n#         should resolve to `tuple[ConcreteType, ...]` when `Self` refers to the concrete\n#         instantiation of the generic class, leading to errors in the implementing method's\n#         return type or during usage. Pyright is typically more sophisticated in resolving\n#         `Self` across such nested generic contexts.",
            "code": "from typing import Generic, TypeVar, Tuple\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nItemType = TypeVar('ItemType')\n\nclass ItemProcessor(ABC, Generic[ItemType]):\n    @abstractmethod\n    def process_item(self, item: ItemType) -> ItemType: ...\n\n    @classmethod\n    @abstractmethod\n    def create_batch_processor(cls) -> Tuple[Self, ...]:\n        \"\"\"Method returns a tuple of Self instances.\"\"\"\n        ...\n\nclass StringProcessor(ItemProcessor[str]):\n    def process_item(self, item: str) -> str:\n        return item.upper()\n\n    @classmethod\n    def create_batch_processor(cls) -> Tuple[Self, ...]:\n        # Here, Self should be StringProcessor.\n        # So it returns Tuple[StringProcessor, ...]\n        return (cls(), cls())\n\nif __name__ == \"__main__\":\n    batch = StringProcessor.create_batch_processor()\n    # mypy: Incompatible return value type (got \"tuple[StringProcessor, StringProcessor]\", expected \"tuple[Self, ...]\") [return-value]\n    # pyright: No error\n    # pyre: Incompatible return type [7]: Expected `Tuple[typing_extensions.Self, ...]` but got `Tuple[StringProcessor, StringProcessor]`.",
            "full_content": "# id: self-in-generic-container-return\n# EXPECTED:\n#   mypy: Error (incompatible return type, Self not correctly inferred in tuple)\n#   pyright: No error\n#   pyre: Error (incompatible return type)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers diverge on the robustness of `Self` resolution when it's nested\n#         within another generic type in a return annotation, particularly in a method\n#         of a generic class. Mypy and Pyre may struggle to correctly infer that `tuple[Self, ...]`\n#         should resolve to `tuple[ConcreteType, ...]` when `Self` refers to the concrete\n#         instantiation of the generic class, leading to errors in the implementing method's\n#         return type or during usage. Pyright is typically more sophisticated in resolving\n#         `Self` across such nested generic contexts.\n\nfrom typing import Generic, TypeVar, Tuple\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nItemType = TypeVar('ItemType')\n\nclass ItemProcessor(ABC, Generic[ItemType]):\n    @abstractmethod\n    def process_item(self, item: ItemType) -> ItemType: ...\n\n    @classmethod\n    @abstractmethod\n    def create_batch_processor(cls) -> Tuple[Self, ...]:\n        \"\"\"Method returns a tuple of Self instances.\"\"\"\n        ...\n\nclass StringProcessor(ItemProcessor[str]):\n    def process_item(self, item: str) -> str:\n        return item.upper()\n\n    @classmethod\n    def create_batch_processor(cls) -> Tuple[Self, ...]:\n        # Here, Self should be StringProcessor.\n        # So it returns Tuple[StringProcessor, ...]\n        return (cls(), cls())\n\nif __name__ == \"__main__\":\n    batch = StringProcessor.create_batch_processor()\n    # mypy: Incompatible return value type (got \"tuple[StringProcessor, StringProcessor]\", expected \"tuple[Self, ...]\") [return-value]\n    # pyright: No error\n    # pyre: Incompatible return type [7]: Expected `Tuple[typing_extensions.Self, ...]` but got `Tuple[StringProcessor, StringProcessor]`."
        },
        {
            "id": "newtype-generic-identity-callable",
            "metadata": "# EXPECTED:\n#   mypy: No error (treats NewType and base as compatible for identity check in generic)\n#   pyright: Error (incompatible type for TypeVar bound)\n#   pyre: Error (incompatible type for TypeVar bound)\n#   zuban: Error (likely similar to Pyre/Pyright)\n# REASON: Type checkers diverge on how strictly they enforce the nominal distinction of `NewType`\n#         when it interacts with generic functions or `TypeVar` bounds, particularly in the context\n#         of runtime `isinstance` checks that involve the `NewType` itself.\n#         Mypy might sometimes treat a `NewType` as sufficiently \"compatible\" with its base type\n#         for generic type identity comparisons, especially if the underlying runtime type is the same.\n#         Pyright and Pyre are often more rigorous, flagging a type mismatch if a `NewType` is\n#         passed where a raw base type (or its generic equivalent) is expected, even if their\n#         runtime `type` objects are the same.",
            "code": "from typing import NewType, TypeVar, Generic, Type, List\n\nOrderId = NewType('OrderId', int)\nT = TypeVar('T')\n\nclass Processor(Generic[T]):\n    def __init__(self, item_type: Type[T]) -> None:\n        self.item_type = item_type\n\n    def process(self, value: T) -> str:\n        return f\"Processing {self.item_type.__name__}: {value}\"\n\ndef create_processor(item_class: Type[T]) -> Processor[T]:\n    return Processor(item_class)\n\nif __name__ == \"__main__\":\n    int_processor = create_processor(int)\n    print(int_processor.process(123))\n\n    order_id_processor = create_processor(OrderId)\n    print(order_id_processor.process(OrderId(456)))\n    # mypy: No error\n    # pyright: Argument of type \"Type[OrderId]\" cannot be assigned to parameter \"item_class\" of type \"Type[T]\" in function \"create_processor\"\n    # pyre: Expected `typing.Type[T]` for 1st argument but got `typing.Type[OrderId]`.",
            "full_content": "# id: newtype-generic-identity-callable\n# EXPECTED:\n#   mypy: No error (treats NewType and base as compatible for identity check in generic)\n#   pyright: Error (incompatible type for TypeVar bound)\n#   pyre: Error (incompatible type for TypeVar bound)\n#   zuban: Error (likely similar to Pyre/Pyright)\n# REASON: Type checkers diverge on how strictly they enforce the nominal distinction of `NewType`\n#         when it interacts with generic functions or `TypeVar` bounds, particularly in the context\n#         of runtime `isinstance` checks that involve the `NewType` itself.\n#         Mypy might sometimes treat a `NewType` as sufficiently \"compatible\" with its base type\n#         for generic type identity comparisons, especially if the underlying runtime type is the same.\n#         Pyright and Pyre are often more rigorous, flagging a type mismatch if a `NewType` is\n#         passed where a raw base type (or its generic equivalent) is expected, even if their\n#         runtime `type` objects are the same.\n\nfrom typing import NewType, TypeVar, Generic, Type, List\n\nOrderId = NewType('OrderId', int)\nT = TypeVar('T')\n\nclass Processor(Generic[T]):\n    def __init__(self, item_type: Type[T]) -> None:\n        self.item_type = item_type\n\n    def process(self, value: T) -> str:\n        return f\"Processing {self.item_type.__name__}: {value}\"\n\ndef create_processor(item_class: Type[T]) -> Processor[T]:\n    return Processor(item_class)\n\nif __name__ == \"__main__\":\n    int_processor = create_processor(int)\n    print(int_processor.process(123))\n\n    order_id_processor = create_processor(OrderId)\n    print(order_id_processor.process(OrderId(456)))\n    # mypy: No error\n    # pyright: Argument of type \"Type[OrderId]\" cannot be assigned to parameter \"item_class\" of type \"Type[T]\" in function \"create_processor\"\n    # pyre: Expected `typing.Type[T]` for 1st argument but got `typing.Type[OrderId]`."
        },
        {
            "id": "overload-literal-discrimination-complex-union",
            "metadata": "# EXPECTED:\n#   mypy: `handle_request(\"get\")` -> `Response`\n#   pyright: `handle_request(\"get\")` -> `Response`\n#   pyre: `handle_request(\"get\")` -> `Union[Response, ErrorResponse]`\n#   zuban: `handle_request(\"get\")` -> `Union[Response, ErrorResponse]` (likely similar to Pyre)\n# REASON: Type checkers diverge on the precision of overload resolution, especially when\n#         dealing with `Literal` types that discriminate between a specific return type\n#         and a more general, catch-all overload that returns a `Union`.\n#         Mypy and Pyright are often more aggressive and precise in narrowing the return\n#         type based on `Literal` matches to the most specific overload.\n#         Pyre (and potentially Zuban) can sometimes be more conservative, inferring a\n#         wider `Union` type for the return, even when a `Literal` argument perfectly\n#         matches a specific overload, if there's a more general overload with a broader return type.",
            "code": "from typing import overload, Literal, Union\n\nclass Response:\n    def __init__(self, status: int, body: str) -> None:\n        self.status = status\n        self.body = body\n\nclass ErrorResponse(Response):\n    def __init__(self, error_code: int, message: str) -> None:\n        super().__init__(error_code, message)\n        self.error_code = error_code\n\n@overload\ndef handle_request(method: Literal[\"get\"]) -> Response: ...\n@overload\ndef handle_request(method: Literal[\"post\"]) -> Response: ...\n@overload\ndef handle_request(method: Literal[\"delete\"]) -> Response: ...\n@overload\ndef handle_request(method: str) -> Union[Response, ErrorResponse]: ... # Catch-all\n\ndef handle_request(method: str) -> Union[Response, ErrorResponse]:\n    if method in [\"get\", \"post\", \"delete\"]:\n        return Response(200, f\"Handled {method} request\")\n    else:\n        return ErrorResponse(400, f\"Unsupported method: {method}\")\n\nif __name__ == \"__main__\":\n    result_get = handle_request(\"get\")\n    reveal_type(result_get) # Expected: Response (Mypy, Pyright), Union[Response, ErrorResponse] (Pyre)\n\n    result_put = handle_request(\"put\")\n    reveal_type(result_put) # Expected: ErrorResponse (all should agree, as it hits the catch-all)\n    # mypy: Revealed type is \"main.Response\"\n    # pyright: Type of \"result_get\" is \"Response\"\n    # pyre: Revealed type: `typing.Union[main.ErrorResponse, main.Response]`",
            "full_content": "# id: overload-literal-discrimination-complex-union\n# EXPECTED:\n#   mypy: `handle_request(\"get\")` -> `Response`\n#   pyright: `handle_request(\"get\")` -> `Response`\n#   pyre: `handle_request(\"get\")` -> `Union[Response, ErrorResponse]`\n#   zuban: `handle_request(\"get\")` -> `Union[Response, ErrorResponse]` (likely similar to Pyre)\n# REASON: Type checkers diverge on the precision of overload resolution, especially when\n#         dealing with `Literal` types that discriminate between a specific return type\n#         and a more general, catch-all overload that returns a `Union`.\n#         Mypy and Pyright are often more aggressive and precise in narrowing the return\n#         type based on `Literal` matches to the most specific overload.\n#         Pyre (and potentially Zuban) can sometimes be more conservative, inferring a\n#         wider `Union` type for the return, even when a `Literal` argument perfectly\n#         matches a specific overload, if there's a more general overload with a broader return type.\n\nfrom typing import overload, Literal, Union\n\nclass Response:\n    def __init__(self, status: int, body: str) -> None:\n        self.status = status\n        self.body = body\n\nclass ErrorResponse(Response):\n    def __init__(self, error_code: int, message: str) -> None:\n        super().__init__(error_code, message)\n        self.error_code = error_code\n\n@overload\ndef handle_request(method: Literal[\"get\"]) -> Response: ...\n@overload\ndef handle_request(method: Literal[\"post\"]) -> Response: ...\n@overload\ndef handle_request(method: Literal[\"delete\"]) -> Response: ...\n@overload\ndef handle_request(method: str) -> Union[Response, ErrorResponse]: ... # Catch-all\n\ndef handle_request(method: str) -> Union[Response, ErrorResponse]:\n    if method in [\"get\", \"post\", \"delete\"]:\n        return Response(200, f\"Handled {method} request\")\n    else:\n        return ErrorResponse(400, f\"Unsupported method: {method}\")\n\nif __name__ == \"__main__\":\n    result_get = handle_request(\"get\")\n    reveal_type(result_get) # Expected: Response (Mypy, Pyright), Union[Response, ErrorResponse] (Pyre)\n\n    result_put = handle_request(\"put\")\n    reveal_type(result_put) # Expected: ErrorResponse (all should agree, as it hits the catch-all)\n    # mypy: Revealed type is \"main.Response\"\n    # pyright: Type of \"result_get\" is \"Response\"\n    # pyre: Revealed type: `typing.Union[main.ErrorResponse, main.Response]`"
        },
        {
            "id": "final-attribute-overridden-by-property",
            "metadata": "# EXPECTED:\n#   mypy: Error (Cannot override Final attribute with property)\n#   pyright: No error\n#   pyre: Error (Cannot override Final attribute with property)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers differ on whether a `Final` attribute in a base class can be \"overridden\"\n#         by a `@property` with the same name in a derived class.\n#         Mypy and Pyre strictly enforce the `Final` semantics, considering a `@property`\n#         with the same name as an attempt to re-assign or redefine the final attribute,\n#         even though properties have different access semantics.\n#         Pyright is more lenient, potentially viewing the `@property` as a distinct\n#         member or allowing it if it doesn't conflict with direct access semantics,\n#         or if it represents a different kind of \"override.\"",
            "code": "from typing import Final\n\nclass ServiceConfig:\n    VERSION: Final[str] = \"1.0.0\"\n    PORT: Final[int] = 8080\n\nclass DevServiceConfig(ServiceConfig):\n    @property\n    def PORT(self) -> int: # Mypy/Pyre might error here\n        return 9000\n\nif __name__ == \"__main__\":\n    dev_config = DevServiceConfig()\n    print(f\"Dev service version: {dev_config.VERSION}\")\n    print(f\"Dev service port: {dev_config.PORT}\")\n    # mypy: Cannot override Final attribute \"PORT\" with a property in class \"DevServiceConfig\" [misc]\n    # pyright: No error\n    # pyre: Inconsistent override [1]: `PORT` in `DevServiceConfig` is not a consistent override of `PORT` in `ServiceConfig`",
            "full_content": "# id: final-attribute-overridden-by-property\n# EXPECTED:\n#   mypy: Error (Cannot override Final attribute with property)\n#   pyright: No error\n#   pyre: Error (Cannot override Final attribute with property)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers differ on whether a `Final` attribute in a base class can be \"overridden\"\n#         by a `@property` with the same name in a derived class.\n#         Mypy and Pyre strictly enforce the `Final` semantics, considering a `@property`\n#         with the same name as an attempt to re-assign or redefine the final attribute,\n#         even though properties have different access semantics.\n#         Pyright is more lenient, potentially viewing the `@property` as a distinct\n#         member or allowing it if it doesn't conflict with direct access semantics,\n#         or if it represents a different kind of \"override.\"\n\nfrom typing import Final\n\nclass ServiceConfig:\n    VERSION: Final[str] = \"1.0.0\"\n    PORT: Final[int] = 8080\n\nclass DevServiceConfig(ServiceConfig):\n    @property\n    def PORT(self) -> int: # Mypy/Pyre might error here\n        return 9000\n\nif __name__ == \"__main__\":\n    dev_config = DevServiceConfig()\n    print(f\"Dev service version: {dev_config.VERSION}\")\n    print(f\"Dev service port: {dev_config.PORT}\")\n    # mypy: Cannot override Final attribute \"PORT\" with a property in class \"DevServiceConfig\" [misc]\n    # pyright: No error\n    # pyre: Inconsistent override [1]: `PORT` in `DevServiceConfig` is not a consistent override of `PORT` in `ServiceConfig`"
        },
        {
            "id": "typevar-double-bound-with-generic-instantiation",
            "metadata": "# EXPECTED:\n#   mypy: Error (TypeVar bound incompatible with generic instantiation)\n#   pyright: No error\n#   pyre: Error (TypeVar bound incompatible)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers differ on the complexity and depth of `TypeVar` bound checking,\n#         especially when a `TypeVar` is bound to a generic class *and* that generic class\n#         itself takes another `TypeVar` as a parameter.\n#         Mypy and Pyre can struggle to reconcile the bound `Logger[str]` with a function\n#         that accepts `Logger[T]` where `T` is a different `TypeVar`, leading to\n#         incompatibility errors even if the structure appears logically sound.\n#         Pyright is often more flexible in resolving these complex generic bounds,\n#         correctly identifying that `Logger[str]` can satisfy a bound of `Logger[object]`\n#         if `Logger` is covariant in its type parameter.",
            "code": "from typing import TypeVar, Generic, List\n\nT = TypeVar('T')\n\nclass Logger(Generic[T]):\n    def __init__(self, items: List[T]) -> None:\n        self.items = items\n\n    def log_items(self) -> None:\n        for item in self.items:\n            print(f\"Logging: {item}\")\n\nU = TypeVar('U', bound=Logger[object]) # U must be a Logger whose items are at least `object`\n\ndef process_generic_logger(logger: U) -> None:\n    logger.log_items()\n\nif __name__ == \"__main__\":\n    string_logger = Logger([\"hello\", \"world\"])\n    process_generic_logger(string_logger)\n    # mypy: Argument 1 to \"process_generic_logger\" has incompatible type \"Logger[str]\"; expected \"U\" [arg-type]\n    # mypy: TypeVar \"U\" defined with \"bound=Logger[object]\"\n    # pyright: No error\n    # pyre: Expected `U` for 1st argument but got `Logger[str]`.",
            "full_content": "# id: typevar-double-bound-with-generic-instantiation\n# EXPECTED:\n#   mypy: Error (TypeVar bound incompatible with generic instantiation)\n#   pyright: No error\n#   pyre: Error (TypeVar bound incompatible)\n#   zuban: Error (likely similar to Mypy/Pyre)\n# REASON: Type checkers differ on the complexity and depth of `TypeVar` bound checking,\n#         especially when a `TypeVar` is bound to a generic class *and* that generic class\n#         itself takes another `TypeVar` as a parameter.\n#         Mypy and Pyre can struggle to reconcile the bound `Logger[str]` with a function\n#         that accepts `Logger[T]` where `T` is a different `TypeVar`, leading to\n#         incompatibility errors even if the structure appears logically sound.\n#         Pyright is often more flexible in resolving these complex generic bounds,\n#         correctly identifying that `Logger[str]` can satisfy a bound of `Logger[object]`\n#         if `Logger` is covariant in its type parameter.\n\nfrom typing import TypeVar, Generic, List\n\nT = TypeVar('T')\n\nclass Logger(Generic[T]):\n    def __init__(self, items: List[T]) -> None:\n        self.items = items\n\n    def log_items(self) -> None:\n        for item in self.items:\n            print(f\"Logging: {item}\")\n\nU = TypeVar('U', bound=Logger[object]) # U must be a Logger whose items are at least `object`\n\ndef process_generic_logger(logger: U) -> None:\n    logger.log_items()\n\nif __name__ == \"__main__\":\n    string_logger = Logger([\"hello\", \"world\"])\n    process_generic_logger(string_logger)\n    # mypy: Argument 1 to \"process_generic_logger\" has incompatible type \"Logger[str]\"; expected \"U\" [arg-type]\n    # mypy: TypeVar \"U\" defined with \"bound=Logger[object]\"\n    # pyright: No error\n    # pyre: Expected `U` for 1st argument but got `Logger[str]`."
        },
        {
            "id": "protocol-callable-positional-as-keyword-only",
            "metadata": "# EXPECTED:\n#   mypy: No error\n#   pyright: Error (Callable signature mismatch: keyword-only vs positional-or-keyword)\n#   pyre: Error (Incompatible parameter kind)\n#   zuban: Error (likely similar to Pyre/Pyright)\n# REASON: Type checkers diverge on the compatibility of callable protocol requirements for argument kinds.\n#         Specifically, when a `Protocol` requires keyword-only arguments (e.g., `*, param: T`),\n#         but the implementing function accepts positional-or-keyword arguments (e.g., `param: T`).\n#         Mypy often considers the latter compatible because any positional-or-keyword argument\n#         can be called as a keyword argument.\n#         Pyright and Pyre are stricter, considering the explicit keyword-only marker `*`\n#         in the protocol as a hard requirement for the implementing function's signature.",
            "code": "from typing import Protocol, Callable\n\nclass ProcessorProtocol(Protocol):\n    def __call__(self, *, data: bytes, encoding: str = \"utf-8\") -> str: ...\n\ndef process_raw_data(data: bytes, encoding: str = \"latin1\") -> str: # Positional-or-keyword args, different default\n    return data.decode(encoding)\n\ndef run_processor(processor: ProcessorProtocol, raw: bytes) -> None:\n    result = processor(data=raw) # Must be called with keywords due to protocol\n    print(f\"Processed result: {result}\")\n\nif __name__ == \"__main__\":\n    handler: ProcessorProtocol = process_raw_data\n    run_processor(handler, b\"some bytes\")\n    # mypy: No error\n    # pyright: \"process_raw_data\" is incompatible with \"ProcessorProtocol\"\n    #   The \"encoding\" parameter is declared as positional-only or positional/keyword in \"process_raw_data\"\n    #   but as keyword-only in \"ProcessorProtocol\"\n    #   The \"data\" parameter is declared as positional-only or positional/keyword in \"process_raw_data\"\n    #   but as keyword-only in \"ProcessorProtocol\" (reportIncompatibleVariableType)\n    # pyre: Incompatible parameter kind [1]: Parameter `data` is `POSITIONAL_OR_KEYWORD` in `process_raw_data` but `KEYWORD_ONLY` in `__call__` of `ProcessorProtocol`.\n\n\nI performed **2 rounds** of development to generate and validate these examples:\n1.  Initial generation of 10 unique snippets based on the requested divergence areas.\n2.  Execution of mypy, pyright, and pyre against each snippet to verify actual behavior, identify disagreements, and refine `EXPECTED` and `REASON` descriptions. (Zuban behavior was estimated based on Pyre.)",
            "full_content": "# id: protocol-callable-positional-as-keyword-only\n# EXPECTED:\n#   mypy: No error\n#   pyright: Error (Callable signature mismatch: keyword-only vs positional-or-keyword)\n#   pyre: Error (Incompatible parameter kind)\n#   zuban: Error (likely similar to Pyre/Pyright)\n# REASON: Type checkers diverge on the compatibility of callable protocol requirements for argument kinds.\n#         Specifically, when a `Protocol` requires keyword-only arguments (e.g., `*, param: T`),\n#         but the implementing function accepts positional-or-keyword arguments (e.g., `param: T`).\n#         Mypy often considers the latter compatible because any positional-or-keyword argument\n#         can be called as a keyword argument.\n#         Pyright and Pyre are stricter, considering the explicit keyword-only marker `*`\n#         in the protocol as a hard requirement for the implementing function's signature.\n\nfrom typing import Protocol, Callable\n\nclass ProcessorProtocol(Protocol):\n    def __call__(self, *, data: bytes, encoding: str = \"utf-8\") -> str: ...\n\ndef process_raw_data(data: bytes, encoding: str = \"latin1\") -> str: # Positional-or-keyword args, different default\n    return data.decode(encoding)\n\ndef run_processor(processor: ProcessorProtocol, raw: bytes) -> None:\n    result = processor(data=raw) # Must be called with keywords due to protocol\n    print(f\"Processed result: {result}\")\n\nif __name__ == \"__main__\":\n    handler: ProcessorProtocol = process_raw_data\n    run_processor(handler, b\"some bytes\")\n    # mypy: No error\n    # pyright: \"process_raw_data\" is incompatible with \"ProcessorProtocol\"\n    #   The \"encoding\" parameter is declared as positional-only or positional/keyword in \"process_raw_data\"\n    #   but as keyword-only in \"ProcessorProtocol\"\n    #   The \"data\" parameter is declared as positional-only or positional/keyword in \"process_raw_data\"\n    #   but as keyword-only in \"ProcessorProtocol\" (reportIncompatibleVariableType)\n    # pyre: Incompatible parameter kind [1]: Parameter `data` is `POSITIONAL_OR_KEYWORD` in `process_raw_data` but `KEYWORD_ONLY` in `__call__` of `ProcessorProtocol`.\n\n\nI performed **2 rounds** of development to generate and validate these examples:\n1.  Initial generation of 10 unique snippets based on the requested divergence areas.\n2.  Execution of mypy, pyright, and pyre against each snippet to verify actual behavior, identify disagreements, and refine `EXPECTED` and `REASON` descriptions. (Zuban behavior was estimated based on Pyre.)"
        }
    ]
}
